---
title: "tennis"
author: "Mihai Matei, Catalin Stefan Cernat 511DS"
date: "3/24/2021"
output:
  html_document:
    df_print: paged
#runtime: shiny
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

## ATP Tennis Visualisation

This project is about tennis ATP results

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
load_packages <- function(package_names) {
  list.of.packages <- as.vector(package_names)
  new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
  if(length(new.packages)) {
    install.packages(new.packages, dependencies=TRUE, repos = "http://cran.us.r-project.org")
  }
  sapply(list.of.packages, require, character.only=TRUE)
}

load_packages(c('rmarkdown', 'tidyverse', 'lubridate', 'reshape2', 'viridis', 'maps', 'RJSONIO', 'glm', "shiny", "shinydashboard", "caret", "kernlab", "e1071", "xgboost", "plotly", "shapr", "arm", "shinyWidgets"))
slice <- dplyr::slice
select <- dplyr::select
```

#### Merging ATP and WTA matches CVS files

```{r, echo=FALSE}
load_data <- function(directory, regex, column_types, col_names=TRUE) {
  list.files(path = directory, pattern = regex, full.names = T) %>%
    lapply( (function (file) read_csv(file, col_types = column_types, col_names = col_names)) ) %>% dplyr::bind_rows()
}

column_types <- cols(
  best_of = 'c',        # Parsed later (factor)
  round = 'c',          # Parsed later (factor)
  tourney_id = 'c',     # Parsed later (factor)
  tourney_name = 'c',   # Parsed later (factor)
  tourney_level = 'c',  # Parsed later (factor)
  surface = 'c',        # Parsed later (factor)
  winner_entry = 'c',   # Parsed later (factor)
  winner_name = 'c',    # Parsed later (factor)
  winner_hand = 'c',    # Parsed later (factor)
  winner_ioc = 'c',     # Parsed later (factor)
  loser_entry = 'c',    # Parsed later (factor)
  loser_name = 'c',     # Parsed later (factor)
  loser_hand = 'c',     # Parsed later (factor)
  loser_ioc = 'c',      # Parsed later (factor)
  winner_id = 'i',
  loser_id = 'i',
  
  winner_age = 'd',
  loser_age = 'd',
  
  draw_size = 'c',      # Parsed later (some non numeric in WTA)
  tourney_date = 'c',   # Parsed later (needs to specify format)
  match_num = 'i',
  winner_seed = 'c',    # Parsed later (some non numeric in WTA)
  winner_ht = 'i',
  loser_seed = 'c',     # Parsed later (some non numeric in WTA)
  loser_ht = 'i',
  minutes = 'i',
  w_ace = 'i',
  w_df = 'i',
  w_svpt = 'i',
  w_1stIn = 'i',
  w_1stWon = 'i',
  w_2ndWon = 'i',
  w_SvGms = 'i',
  w_bpSaved = 'i',
  w_bpFaced = 'i',
  l_ace = 'i',
  l_df = 'i',
  l_svpt = 'i',
  l_1stIn = 'i',
  l_1stWon = 'i',
  l_2ndWon = 'i',
  l_SvGms = 'i',
  l_bpSaved = 'i',
  l_bpFaced = 'i',
  winner_rank = "i",
  winner_rank_points = 'i',
  loser_rank = "i",
  loser_rank_points = 'i'
)

#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

singles_atp_DF <- load_data('./data/tennis_atp', "atp_matches_\\d*.csv", column_types)
singles_wta_DF <- load_data('./data/tennis_wta', "wta_matches_\\d*.csv", column_types)

combined_DF <- bind_rows(list(ATP = singles_atp_DF, WTA = singles_wta_DF), .id = "league") %>%
  separate(col = tourney_id, into=c("year", "tourney_id"), sep="-", extra="merge") %>%
  mutate(league = factor(league),
         best_of = factor(best_of, ordered = TRUE, levels = c("3", "5")),
         round = factor(round, ordered = TRUE, levels = c("Q4", "ER", "BR", "RR", "R128", "R64", "R32", "R16", "QF", "SF", "F")),
         
         tourney_name = factor(tourney_name),
         tourney_level = factor(tourney_level),
         surface = factor(surface),
         winner_entry = factor(winner_entry),
         winner_name = factor(winner_name),
         winner_hand = factor(winner_hand),
         winner_ioc = factor(winner_ioc),
         loser_entry = factor(loser_entry),
         loser_name = factor(loser_name),
         loser_hand = factor(loser_hand),
         loser_ioc = factor(loser_ioc),

         tourney_id = factor(tourney_id),
         year = as.integer(year),
         tourney_date = parse_date(tourney_date, format="%Y%m%d"),
         
         draw_size = suppressWarnings(as.numeric(draw_size)),
         winner_seed = suppressWarnings(as.numeric(winner_seed)),
         loser_seed = suppressWarnings(as.numeric(loser_seed)),
         
         w_1stPercWon = (w_1stWon / w_1stIn),
         l_1stPercWon = (l_1stWon / l_1stIn),
         w_breaks = (l_bpFaced - l_bpSaved),
         l_breaks = (w_bpFaced - w_bpSaved)
         )

```

#### Merging ATP and WTA player CSV files

```{r, echo=FALSE}
col_names <- c(
  "player_id", "first_name", "last_name", "hand", "birth_date", "ioc"
)

column_types <- cols(
  player_id = "i",
  first_name = "c",
  last_name = "c",
  hand = "c",       # Parsed later (factor)
  birth_date = "c", # Parsed later (needs to specify format)     
  ioc = "c"         # Parsed later (factor)
)


players_atp_DF <- load_data('./data/tennis_atp', "atp_players.csv", column_types, col_names)
players_wta_DF <- load_data('./data/tennis_wta', "wta_players.csv", column_types, col_names)

players_DF <- bind_rows(list(ATP = players_atp_DF, WTA = players_wta_DF), .id = "league") %>%
  mutate(
    league = factor(league),
    hand = factor(hand),
    birth_date = suppressWarnings(parse_date(birth_date, format="%Y%m%d")),
    ioc = factor(ioc))
```

#### Merging ATP and WTA rankings CSV files

```{r, echo=FALSE}
col_names <- c("ranking_date", "rank", "player", "points")
column_types <- cols(
  ranking_date = "c", # Parsed later (needs to specify format)
  rank = "i",
  player = "i",
  points = "i"
)


rankings_atp_DF <- load_data('./data/tennis_atp', "atp_rankings_(70|80|90|00|10)s.csv", column_types) %>%
  bind_rows(load_data('./data/tennis_atp', "atp_rankings_(20)s.csv", column_types, col_names))


col_names <- c("ranking_date", "rank", "player", "points", "undefined")
column_types <- cols(
  ranking_date = "c", # Parsed later (needs to specify format)
  rank = "i",
  player = "i",
  points = "i",
  undefined = "c"     # Extra column
)

rankings_wta_DF <- load_data('./data/tennis_wta', "wta_rankings_(80|90|00|20)s.csv", column_types, col_names) %>%
  bind_rows(load_data('./data/tennis_wta', "wta_rankings_(10)s.csv", column_types)) %>%
  select(c("ranking_date", "rank", "player", "points"))


rankings_DF <- bind_rows(list(ATP = rankings_atp_DF, WTA = rankings_wta_DF), .id = "league") %>%
  mutate(
    league = factor(league),
    ranking_date = parse_date(ranking_date, format="%Y%m%d")
    )
```

#### Load Country Codes CSV file
```{r, echo=FALSE}
column_types <- cols(
  country = "c",
  ioc = "c"
)

country_DF <- load_data('./data', "country_codes.csv", column_types)
```


### EDA

#### Number of matches per year
Visualize how the number of matcher per league evoluted along each year. Notice the impact of the coronavirul pandemy.

```{r, echo=FALSE}
ggplot(combined_DF %>% group_by(league, year) %>% summarise(no_matches = length(year), .groups = 'drop'),
       aes(x=year, y=no_matches, group=league)) +
  scale_x_continuous(breaks=seq(1848, 2021, 5)) +
  geom_line(aes(color=league), size=1) + 
  scale_color_manual(values=c('blue','red')) +
  labs(x="Year", y="Number of matches", title="Number of matches per year") +
  geom_vline(xintercept=2020, linetype="dotted", color="black", size=0.7) +
  geom_text(aes(x=2020, label="CORONAVIRUS", y=3500), angle=90) +
  theme_classic()
```

#### Player hand statistics

Visualize how many players in both leagues use left, right or both hands for backhand

```{r, echo=FALSE}
ggplot(combined_DF %>% filter(!is.na(winner_hand)) %>% group_by(league, winner_id, winner_hand) %>% distinct(winner_id)) +
  geom_bar(aes(winner_hand, fill = league), position = "dodge") +
  scale_fill_manual(values=c('blue','red')) +
  labs(x="Player hand", y="Number of players", title="Bar plot for number of players by hand") +
  theme_classic()
```

Visualize how many matches are played per league depending on backhand
```{r, echo=FALSE}
ggplot(combined_DF %>% filter(!is.na(winner_hand) & !is.na(loser_hand)) %>%
         group_by(league, winner_hand, loser_hand) %>% summarise(no_matches = length(winner_hand), .groups = 'drop'),
       aes(winner_hand, loser_hand)) +
  geom_tile(aes(fill=no_matches)) +
  scale_fill_gradient(low = "light gray", high = "blue") +
  labs(x="Winner hand", y="Loser hand", title="Tile plot for number of matches by backhand") +
  theme_classic() +
  facet_wrap(~league, nrow=1)
```

#### Round statistics

Visualize the average match length by round type
```{r, echo=FALSE}

# Get lower and upper whiskers
ylim <- boxplot.stats((combined_DF %>% filter(!is.na(minutes)))$minutes)$stats[c(1, 5)]

ggplot(combined_DF %>% filter(!is.na(minutes)) %>% group_by(league, round) %>%
         filter(round != "BR", round != "ER", round != "Q4"),
       aes(round, minutes)) +
  geom_boxplot(aes(fill=league), outlier.shape = NA) +
  coord_cartesian(ylim = ylim * 1.5) +
  labs(x="Winner hand", y="Loser hand", title="Box plot for match duration by round")
```


#### Rank difference

Visualize the average rank by player age
```{r, echo=FALSE}

ggplot(players_DF %>% select(league, player_id, birth_date) %>%
         inner_join(rankings_DF %>% select(league, player, ranking_date, rank), by = (c("league" = "league", "player_id" = "player"))) %>%
         mutate(age = floor(time_length(difftime(ranking_date, birth_date), "years"))) %>%
         filter(age > 10, age < 60) %>%
         group_by(league, age) %>% summarise(avg_rank = mean(rank)),
       aes(age, avg_rank)) +
  geom_line(aes(color=league)) +
  scale_x_continuous(breaks=seq(10, 60, 5)) +
  scale_y_reverse() +
  labs(x="Player Age", y="Average rank", title="Average Rank by Age")
```

Visualize the average rank by player age (only looking at top 20)
```{r, echo=FALSE}

ggplot(players_DF %>% select(league, player_id, birth_date) %>%
         inner_join(rankings_DF %>% select(league, player, ranking_date, rank), by = (c("league" = "league", "player_id" = "player"))) %>%
         mutate(age = floor(time_length(difftime(ranking_date, birth_date), "years"))) %>%
         filter(age > 10, age < 60, rank < 20) %>%
         group_by(league, age) %>% summarise(avg_rank = mean(rank)),
       aes(age, avg_rank)) +
  geom_line(aes(color=league)) +
  scale_x_continuous(breaks=seq(10, 60, 5)) +
  scale_y_reverse() +
  labs(x="Player Age", y="Average rank", title="Average Rank by Age (Top 20)")
```

Visualize the distribution of rank difference of players in matches. Notice is gaussian with 0 mean.
```{r, echo=FALSE}
ggplot(combined_DF %>% filter(!is.na(winner_rank) & !is.na(loser_rank)) %>% 
         group_by(league, winner_rank, loser_rank) %>% summarise(rank_difference = winner_rank - loser_rank, .groups = 'drop'),
       aes(x=rank_difference)) +
  geom_freqpoly(aes(color=league), bins=100) +
  scale_color_manual(values=c('blue','red')) +
  labs(x="Winner rank difference", y="Number of matches", title="Player rank difference of played matches") +
  theme_classic()
```



#### Serve statistics

Visualize the percentage of serves won if 1st serve is inside the court (How strong players 1st serve is)
```{r, echo=FALSE}
ggplot(combined_DF %>% select(league, w_1stPercWon) %>% rename(perc_won = w_1stPercWon) %>%
         bind_rows(combined_DF %>% select(league, l_1stPercWon) %>% rename(perc_won = l_1stPercWon)) %>%
         filter(!is.na(perc_won)),
       aes(perc_won, group=league, fill=league)) +
  geom_density() +
  facet_wrap(~league) +
  labs(x="Percentage won", y="Density", title="Percentage of 1st serves won (if serve is in)")
```

Correlation between serves and breaks with match wins
```{r, echo=FALSE}
serves_correlation <- cor(
  combined_DF %>%
    select(w_1stIn, w_1stWon, w_2ndWon, w_breaks) %>%
    filter(!is.na(w_1stIn), !is.na(w_1stWon), !is.na(w_2ndWon), !is.na(w_breaks)) %>%
    rename(fstIn = w_1stIn, fstWon = w_1stWon, sndWon = w_2ndWon, breaks = w_breaks) %>% mutate(win = 1) %>%
    bind_rows(combined_DF %>%
                select(l_1stIn, l_1stWon, l_2ndWon, l_breaks) %>%
                filter(!is.na(l_1stIn), !is.na(l_1stWon), !is.na(l_2ndWon), !is.na(l_breaks)) %>%
                rename(fstIn = l_1stIn, fstWon = l_1stWon, sndWon = l_2ndWon, breaks = l_breaks) %>% mutate(win = 0))
)

ggplot(data = melt(serves_correlation), aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile() +
  scale_fill_viridis_c() +
  labs(x="Variable 1", y="Variable 2", title="Correlation Matrix for serves and breaks")
```

#### Tourney statistics

Plot the top tourney matches player per year
```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
top_tourney <- combined_DF %>% count(tourney_name) %>% top_n(6)
ggplot(combined_DF %>% filter(tourney_name %in% top_tourney$tourney_name) %>% group_by(tourney_name) %>% count(year)) + 
  geom_line(aes(x=year, y=n, color=tourney_name), size=1) +
  labs(x="Year", y="Number of matches", color="Tourney", title="Matches per year of top tournaments") +
  theme_minimal()
```

Plot the location on the map of the tourneys. Get the latitude and coordonates from tourney name using openstreetmap

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
get_coordonates <- function(df) {
  long <- double(nrow(df))
  lat <- double(nrow(df))

  for (row in 1:nrow(df)) {
    name <- df[row, "tourney_name"]
    url <- paste("http://nominatim.openstreetmap.org/search?city=", name$tourney_name, "&limit=1&format=json", sep="")
    data <- fromJSON(url)
    if(is.vector(data)){
      long[row] <- data[[1]]$lon
      lat[row] <- data[[1]]$lat
    }
  }

  return (data.frame(tourney_name=df$tourney_name, long=long, lat=lat) %>% mutate(
    tourney_name=as.character(tourney_name),
    long=as.double(long),
    lat=as.double(lat)
  ))
}

tourney_coordonates_DF <- get_coordonates(combined_DF %>% count(tourney_name) %>% top_n(50)) %>% filter(long!=0 & lat!=0)
ggplot(map_data("world"), aes(x=long, y=lat)) +
  geom_polygon(aes(group=group, fill=region ), color="white") +
  geom_text(data=tourney_coordonates_DF, aes(label=tourney_name), size=3, hjust=0.5) +
  geom_point(data=tourney_coordonates_DF, color="red", size=2) +
  scale_fill_viridis_d() +
  theme_void() + theme(legend.position = "none")
```



Plot top 10 countries by number of Grand Slams won for ATP and WTA
```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}

country_atp_g_wins <- combined_DF %>%
  filter(league == 'ATP', round == 'F', tourney_level == 'G') %>%
  group_by(league) %>% count(winner_ioc, name = "tourney_wins") %>%
  slice_max(tourney_wins, n = 10) %>%
  left_join(country_DF, by=c("winner_ioc" = "ioc")) %>%
  mutate(country=replace(country, winner_ioc == 'USA', 'USA')) %>%
  ungroup()

maps_atp_g_wins <- map_data("world", region = country_atp_g_wins$country) %>%
  filter(is.na(subregion) | subregion != 'Alaska'& subregion != 'Hawaii') %>%
  left_join(country_atp_g_wins %>% select(country, tourney_wins), by = c("region" = "country")) %>%
  mutate(region = fct_reorder(region, tourney_wins, .desc = TRUE))

ggplot(maps_atp_g_wins,  aes(x = long, y = lat)) +
  geom_map(map = maps_atp_g_wins, aes(map_id = region, fill=region)) +
  facet_wrap(~region + tourney_wins, scale="free", labeller = label_wrap_gen(multi_line = FALSE)) +
  theme_void() +
  labs(title="Top 10 countries by number of ATP Grand Slams won")
```


```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}

country_wta_g_wins <- combined_DF %>%
  filter(league == 'WTA', round == 'F', tourney_level == 'G') %>%
  group_by(league) %>% count(winner_ioc, name = "tourney_wins") %>%
  slice_max(tourney_wins, n = 10) %>%
  left_join(country_DF, by=c("winner_ioc" = "ioc")) %>%
  mutate(country=replace(country, winner_ioc == 'USA', 'USA')) %>%
  mutate(country=replace(country, winner_ioc == 'GBR', 'UK')) %>%
  ungroup()

maps_wta_g_wins <- map_data("world", region = country_wta_g_wins$country) %>%
  filter(is.na(subregion) | subregion != 'Alaska'& subregion != 'Hawaii') %>%
  left_join(country_wta_g_wins %>% select(country, tourney_wins), by = c("region" = "country")) %>%
  mutate(region = fct_reorder(region, tourney_wins, .desc = TRUE))

ggplot(maps_wta_g_wins,  aes(x = long, y = lat)) +
  geom_map(map = maps_wta_g_wins, aes(map_id = region, fill=region)) +
  facet_wrap(~region + tourney_wins, scale="free", labeller = label_wrap_gen(multi_line = FALSE)) +
  theme_void() +
  labs(title="Top 10 countries by number of WTA Grand Slams won")
```


```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
x <- ggplot(combined_DF %>% filter(!is.na(winner_ht))) +
  geom_histogram(aes(x=winner_ht, fill=league), alpha = .65, position = 'identity') +
  scale_x_continuous(breaks=seq(120, 240, 5))
ggplotly(x)
```


### Regression models for predicting winner player's rank

Dashboard for linear models

```{r, echo=FALSE}

split_data <- function(data, test) {
  spec = c(train = 1 - test, test = test)
  N = nrow(data)
  
  set.seed(Sys.time())
  data_split = sample(cut( seq(N), N * cumsum(c(0, spec)), labels = names(spec) ))
  
  return(split(data, data_split))
}

# Setting up features and target
data_set <- combined_DF %>% filter(year > 1980) %>%
  select(c(winner_rank, year, winner_age,
           loser_age, minutes, w_ace, w_df, l_ace, l_df)) %>%
  na.omit() %>%
  split_data(0.1)


# Regression Models
r_models <- c()
# Linear with different IC
r_models$lm <- lm(winner_rank ~ ., data_set$train)
r_models$aic <- step(r_models$lm, trace=0)
r_models$bic <- step(r_models$lm, trace=0, k=log(nrow(data_set$train)))

# Generalized Linear model
r_models$glm <- glm(winner_rank ~ .  , family=quasi(), data=data_set$train)

# XgBoost
data_matrix <- c()
data_matrix$train <- c()
data_matrix$train$X = as.matrix(data_set$train)[,2:ncol(data_set$train)]
data_matrix$train$Y = as.matrix(data_set$train)[,1]
data_matrix$test <- c()
data_matrix$test$X = as.matrix(data_set$test)[,2:ncol(data_set$test)]
data_matrix$test$Y = as.matrix(data_set$test)[,1]
r_models$xgb <- xgboost(data=data_matrix$train$X, label=data_matrix$train$Y,
                        nrounds=2000, objective = "reg:squarederror", verbose=0)

ui_tab <- function(name, text, width=600) {
  tabItem(tabName = name,
          fluidRow(
            h3(text),
            box(plotOutput(paste0(name, "_res"), width=width, height = 400), width=width, collapsible=TRUE)),
          fluidRow(
            box(plotOutput(paste0(name, "_sha"), width=width, height = 400), width=width, collapsible=TRUE)),
          fluidRow(
            box(h4("Model Performance"),
                verbatimTextOutput(paste0(name, "_p")), width=width, collapsible=TRUE)),
          fluidRow(
            box(h4("Model Summary"),
            verbatimTextOutput(paste0(name, "_s")), width=width, collapsible=TRUE)))
}

ui <- dashboardPage(
  dashboardHeader(title = "Winner Rank"),
  dashboardSidebar(
    div("Regression Models"),
    sidebarMenu(
      menuItem("Linear Model", tabName = "lm", icon = icon("th")),
      menuItem("Linear Model with AIC", tabName = "aic", icon = icon("th")),
      menuItem("Linear Model with BIC", tabName = "bic", icon = icon("th")),
      menuItem("General Linear Model", tabName = "glm", icon = icon("th")),
      menuItem("XGBoost", tabName = "xgb", icon = icon("th"))
    )
  ),

  dashboardBody(
    tabItems(
      ui_tab("lm", "Plain Linear Model"),
      ui_tab("aic", "Linear Model with Akaike Information Criterion"),
      ui_tab("bic", "Linear Model with Bayesian Information Criterion"),
      ui_tab("glm", "General Linear Model"),
      ui_tab("xgb", "Extreme Gradient Boosting Tree")
      )
    )
  )

rsquared <- function(true, predicted, has_intercept) {
  sse <- sum((predicted - true)^2)
  sst <- ifelse(has_intercept, sum((true - mean(true))^2), sum(true^2))
  rsq <- 1 - sse / sst

  return (round(rsq, digits=5))
}

mean_squared_error <- function(true, predicted) {
  return( round(mean((predicted - true) ^ 2), digits=5) )
}

server <- function(input, output) {
  
  plot_residuals <- function(model, name, data) {
    y_hat <- tryCatch(
      {predict(model, data %>% select(-c(winner_rank)))},
      error=function(cond) {
        predict(model, as.matrix(data %>% select(-c(winner_rank))))
      }
    )
    residuals <- data$winner_rank - y_hat
    ggplot(data.frame(Residuals=abs(residuals), Predictions=y_hat), aes(Predictions, Residuals)) +
      geom_point(color="blue") +
      labs(title=paste0("Homoscedascity for residuals of ", name)) +
      theme_bw() + theme(plot.title = element_text(hjust = 0.5))
  }

  plot_shapr <- function(model, data_set) {
    explainer <- shapr(data_set$train %>% select(-c(winner_rank)), model)
    # for first 4 test samples
    explanation <- explain(data_set$test %>% select(-c(winner_rank)) %>% slice(1:4), approach="gaussian",
                           explainer=explainer, prediction_zero=mean(data_set$train$winner_rank))
    plot(explanation, plot_phi0 = FALSE)
  }

  print_performance <- function(model, data_set) {
    y_hat_train <- tryCatch(
      {predict(model, data_set$train %>% select(-c(winner_rank)))},
      error=function(cond) {
        predict(model, as.matrix(data_set$train %>% select(-c(winner_rank))))
      }
    )
    y_hat_test <- tryCatch(
      {predict(model, data_set$test %>% select(-c(winner_rank)))},
      error=function(cond) {
        predict(model, as.matrix(data_set$test %>% select(-c(winner_rank))))
      }
    )

    paste0('   TRAIN R^2: ', rsquared(data_set$train$winner_rank, y_hat_train, TRUE),
           '   TRAIN MSE: ', mean_squared_error(data_set$train$winner_rank, y_hat_train),
           '   TEST R^2: ', rsquared(data_set$test$winner_rank, y_hat_test, TRUE),
           '   TEST MSE: ', mean_squared_error(data_set$test$winner_rank, y_hat_test))
  }

  output$lm_res <- renderPlot({plot_residuals(r_models$lm, "Linear Model", data_set$train)})
  output$lm_sha <- renderPlot({plot_shapr(r_models$lm, data_set)})
  output$lm_p <- renderPrint({print_performance(r_models$lm, data_set)})
  output$lm_s <- renderPrint({summary(r_models$lm)})
  
  output$aic_res <- renderPlot({plot_residuals(r_models$aic, "AIC Linear Model", data_set$train)})
  output$aic_sha <- renderPlot({plot_shapr(r_models$aic, data_set)})
  output$aic_p <- renderPrint({print_performance(r_models$aic, data_set)})
  output$aic_s <- renderPrint({summary(r_models$aic)})
  
  output$bic_res <- renderPlot({plot_residuals(r_models$bic, "BIC Linear Model", data_set$train)})
  output$bic_sha <- renderPlot({plot_shapr(r_models$bic, data_set)})
  output$bic_p <- renderPrint({print_performance(r_models$bic, data_set)})
  output$bic_s <- renderPrint({summary(r_models$bic)})
  
  output$glm_res <- renderPlot({plot_residuals(r_models$glm, "General Linear Model", data_set$train)})
  output$glm_sha <- renderPlot({plot_shapr(r_models$glm, data_set)})
  output$glm_p <- renderPrint({print_performance(r_models$glm, data_set)})
  output$glm_s <- renderPrint({summary(r_models$glm)})

  output$xgb_res <- renderPlot({plot_residuals(r_models$xgb, "Extreme Gradient Boosting", data_set$train)})
  output$xgb_sha <- renderPlot({plot_shapr(r_models$xgb, data_set)})
  output$xgb_p <- renderPrint({print_performance(r_models$xgb, data_set)})
  output$xgb_s <- renderPrint({summary(r_models$xgb)})
}

shinyApp(ui, server, options=list(height=1200))
```


### Classification models for predicting who will win a match
```{r, echo=FALSE}
average_stat <- function(stat, league) {
  w_stat <- paste('winner_', stat, sep = "")
  l_stat <- paste('loser_', stat, sep = "")

  return ((combined_DF %>%
            select(stat_1 = w_stat, stat_2 = l_stat) %>%
            filter(!is.na(stat_1), !is.na(stat_2), league == league) %>%
            mutate(avg_stat = (stat_1 + stat_2) / 2) %>%
            summarise(value = mean(avg_stat)))$value)
}

max_or_default <- function(values, default) {
  if (all(is.na(values))) {
    return (default)
  } else {
    return (max(values, na.rm = TRUE))
  }
}

get_player_stats <- function(end_date, period) {

  # Compute average values to replace nas
  avg_age_atp <- average_stat('age', 'ATP')
  avg_age_wta <- average_stat('age', 'WTA')
  avg_ht_atp <- average_stat('ht', 'ATP')
  avg_ht_wta <- average_stat('ht', 'WTA')

  recent_matches_DF <- combined_DF %>% filter(tourney_date >= end_date - years(period), tourney_date < end_date)
  
  # Transform matches data frame - separate winner and loser stats on different rows
  recent_matches_t_DF <- recent_matches_DF %>%
    rename(player_id=winner_id, bpFaced=w_bpFaced, bpSaved=w_bpSaved, breaks=w_breaks,
           aces=w_ace, p1stWon = w_1stWon,  p1stIn = w_1stIn, df = w_df, age = winner_age,
           ht = winner_ht) %>%
    bind_rows(recent_matches_DF %>%
                rename(player_id=loser_id, bpFaced=l_bpFaced, bpSaved=l_bpSaved, breaks=l_breaks,
                       aces = l_ace, p1stWon = l_1stWon,  p1stIn = l_1stIn, df = l_df, age = loser_age,
                       ht = loser_ht))
  
  # Create a players statistics data frame
  players_stats_DF <- recent_matches_t_DF %>% group_by(league, player_id) %>%
    replace_na(list(breaks=0, matches=0, aces=0, p1stWon = 0, p1stIn = 0, df = 0)) %>%
    summarise(matches = n(), breaksP = sum(breaks) / n(), acesP = sum(aces) / n(),
              dfP = sum(df) / n(), p1stWonP = sum(p1stWon) / sum(p1stIn),
              age = max_or_default(age, if(league[1] == 'ATP') avg_age_atp else avg_age_wta),
              ht = max_or_default(ht, if(league[1] == 'ATP') avg_ht_atp else avg_ht_wta)) %>%
    ungroup() %>%
    replace_na(list(p1stWonP=0))
  
  return (players_stats_DF)
}

get_observations <- function(matches, player_stats_period) {
  earliest_tourney <- matches %>% slice(which.min(tourney_date)) %>% .$tourney_date
  player_stats <- get_player_stats(earliest_tourney, player_stats_period)

  observations <- matches %>%
    left_join(player_stats, by=c("winner_id"="player_id", "league"="league")) %>%
    left_join(player_stats, by=c("loser_id"="player_id", "league"="league"), suffix=c(".w", ".l")) %>%
    replace_na(list(winner_rank=0, loser_rank=0, winner_rank_points=0, loser_rank_points=0, surface='Hard',
                    age.w=0, age.l=0, ht.w=0, ht.l=0, matches.w=0, matches.l=0, breaksP.w=0, breaksP.l=0,
                    acesP.w=0, acesP.l=0, dfP.w=0, dfP.l=0, p1stWonP.w=0, p1stWonP.l=0))
  
  print(colSums(is.na(observations)))
  
  n_rows <- observations %>% nrow()
  observations_pos <- observations %>% sample_n((n_rows + 1)/ 2, replace=FALSE)
  observations_neg <- anti_join(observations, observations_pos)
  
  observations_pos <- observations_pos %>% mutate(rank_d = winner_rank - loser_rank,
                       points_d = winner_rank_points - loser_rank_points,
                       age_d = age.w- age.l,
                       ht_d = ht.w - ht.l,
                       matches_d = matches.w - matches.l,
                       breaksP_d = breaksP.w - breaksP.l,
                       acesP_d = acesP.w - acesP.l,
                       dfP_d = dfP.w - dfP.l,
                       p1stWonP_d = p1stWonP.w - p1stWonP.l,
                       target = 1) %>%
    select(league, age_d, ht_d, rank_d, points_d, matches_d, breaksP_d, acesP_d, dfP_d, p1stWonP_d, target)
  
  observations_neg <- observations_neg %>% mutate(rank_d = loser_rank - winner_rank,
                       points_d = loser_rank_points - winner_rank_points,
                       age_d = age.l- age.w,
                       ht_d = ht.l - ht.w,
                       matches_d = matches.l - matches.w,
                       breaksP_d = breaksP.l - breaksP.w,
                       acesP_d = acesP.l - acesP.w,
                       dfP_d = dfP.l - dfP.w,
                       p1stWonP_d = p1stWonP.l - p1stWonP.w,
                       target = -1) %>%
    select(league, age_d, ht_d, rank_d, points_d, matches_d, breaksP_d, acesP_d, dfP_d, p1stWonP_d, target)

  return (observations_pos %>%
            bind_rows(observations_neg) %>%
            mutate(target = factor(target))
          )
}

# Data Split
train_matches <- combined_DF %>% filter(tourney_date >= '2017-01-01', tourney_date < '2018-01-01' )
valid_matches <- combined_DF %>% filter(tourney_date >= '2018-01-01', tourney_date < '2019-01-01' )
test_matches <- combined_DF %>% filter(tourney_date >= '2019-01-01', tourney_date < '2020-01-01' )
test_grand_slams <- test_matches %>% filter(tourney_level == 'G')
ui_filtered_matches <- test_grand_slams

# Observations
observations_train <- get_observations(train_matches, 5)
observations_valid <- get_observations(valid_matches, 5)
observations_test <- get_observations(test_matches, 5)


# Train Models
train_rows <- observations_train %>% nrow()
train_idx <- c(1:train_rows)
valid_rows <- observations_valid %>% nrow()
valid_idx <- c((train_rows + 1):(train_rows + valid_rows))

trControl <- trainControl(
 index = list(train_idx),
 indexOut = list(valid_idx),
 indexFinal = valid_idx
)


# KNN
grid <- expand.grid(k = c(3, 5, 7, 9, 11, 13)) 
knn_model <- train(target ~ .,
                   data =  observations_train %>% bind_rows(observations_valid),
                   method = "knn",
                   preProcess = c("center","scale"),
                   trControl = trControl,
                   tuneGrid = grid)

# Random Forest
grid <- expand.grid(.mtry = (1:(ncol(observations_train) - 1)))
rf_model <- train(target ~ .,
                 data = observations_train %>% bind_rows(observations_valid), 
                 method = 'rf', 
                 trControl = trControl,
                 tuneGrid = grid,
                 ntree = 15)


# Logistic Regression
lgreg_model <- train(target ~ .,
                 data = observations_train %>% bind_rows(observations_valid), 
                 method = 'bayesglm',
                 trControl = trControl)


# SVM
grid <- expand.grid(C = seq(0.1, 2, length=5))
svm_model <- train(target ~ .,
                 data = observations_train %>% bind_rows(observations_valid), 
                 method = 'svmLinear', 
                 preProcess = c("center","scale"),
                 tuneGrid = grid,
                 trControl = trControl)


# XG Boost
grid <- expand.grid(
  nrounds = 50,
  eta = c(0.05, 0.1),
  max_depth = c(2, 4),
  gamma = c(0.05, 0.1, 0.5),
  colsample_bytree = 1,
  min_child_weight = 1,
  subsample = 1
)
xgb_model <- train(target ~ .,
                 data = observations_train %>% bind_rows(observations_valid), 
                 method = 'xgbTree', 
                 trControl = trControl)

knn_model
plot(knn_model)
knn_predict <- predict(knn_model, newdata = observations_test)
confusionMatrix(knn_predict, observations_test$target)

rf_model
plot(rf_model)
rf_predict <- predict(rf_model, newdata = observations_test)
confusionMatrix(rf_predict, observations_test$target)

xgb_model
plot(xgb_model)
xgb_predict <- predict(xgb_model, newdata = observations_test)
confusionMatrix(xgb_predict, observations_test$target)

svm_model
plot(svm_model)
svm_predict <- predict(svm_model, newdata = observations_test)
confusionMatrix(svm_predict, observations_test$target)

lgreg_model
logr_predict <- predict(lgreg_model, newdata = observations_test)
confusionMatrix(logr_predict, observations_test$target)


class_ui <- dashboardPage(
  dashboardHeader(title = "Classification"),
  dashboardSidebar(
    div("Model"),
    sidebarMenu(
      menuItem("Grand Slam Predictions", tabName = "gsp", icon = icon("th"))
    )
  ),

  dashboardBody(
    tabItems(
      tabItem(tabName = "gsp",
              fluidRow(
                h3("Grand Slam Predictions"),
                pickerInput(inputId="in_league", label="Select League", choices=c('WTA', 'ATP')),
                pickerInput(inputId="in_tourney_name", label="Select Tourney", choices=c()),
                pickerInput(inputId="in_tourney_round", label="Select Round", choices=c()),
                pickerInput(inputId="in_tourney_match", label="Select Match", choices=c('000 - '))
              ),
              fluidRow(
                h3("Odds"),
                box(width=600, height = 400, plotOutput("odds_plot", width=600, height = 400))
              )
      )
    )
  )
)

class_server <- function(input, output, session) {
  ui_filtered_matches <- reactive({
    return (test_grand_slams %>% filter(league == input$in_league,
                                        if (!is.null(input$in_tourney_name)) tourney_name == input$in_tourney_name else TRUE,
                                        if (!is.null(input$in_tourney_round)) round == input$in_tourney_round else TRUE
                                        )
                                )
  })

  match <- reactive({
    s_match_num <- strsplit(input$in_tourney_match, " - ")[[1]][1]
    selected_match <- ui_filtered_matches() %>% filter(match_num == s_match_num)
    return (selected_match)
  })

  observeEvent(ui_filtered_matches(), {
    tourney_names <- lapply(test_grand_slams %>% filter(league == input$in_league)
                            %>% distinct(tourney_name) %>% .$tourney_name, as.character)
    rounds <- if (!is.null(input$in_tourney_name)) {
      lapply(test_grand_slams %>% filter(league == input$in_league, tourney_name == input$in_tourney_name)
                       %>% distinct(round) %>% .$round, as.character)
    } else c()

    matches <- ui_filtered_matches() %>% select(match_num, winner_name, loser_name) %>%
      summarise(match_desc = paste0(match_num, " - ", winner_name, " VS ", loser_name)) %>%
      .$match_desc

    updatePickerInput(session = session, inputId="in_tourney_name",
                      choices = tourney_names, selected = input$in_tourney_name)

    updatePickerInput(session = session, inputId="in_tourney_round",
                      choices = rounds, selected = input$in_tourney_round)

    updatePickerInput(session = session, inputId="in_tourney_match",
                      choices = matches)
  })

  observeEvent(match(), {
    if (match() %>% nrow() > 0) {
      obs <- get_observations(match(), 5)
      logr_predict <- predict(lgreg_model, newdata = obs, type="prob")

      w_name <- as.character(match() %>% .$winner_name)
      l_name <- as.character(match() %>% .$loser_name)
      odds_df <- tibble(name=c(l_name, w_name), probs = unlist(logr_predict))

      output$odds_plot <- renderPlot({
        odds_df %>% ggplot(aes(name, probs)) + geom_bar(stat="identity")
      })
    }
  })
}

shinyApp(class_ui, class_server, options=list(height=800))
```